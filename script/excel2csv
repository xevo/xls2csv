#!/bin/env perl
use strict;

use Getopt::Long;
use Term::ANSIColor;

my $file;
my $match;
my $nocolor;
my $column_width = 20;
my $errors_only;
my $check_line;

GetOptions(
    "file=s"  => \$file,
    "match=s" => \$match,
    "nocolor" => \$nocolor,
    "width=i" => \$column_width,
    "errors" => \$errors_only,
    "check_line=i" => \$check_line,
    );

$ENV{ANSI_COLORS_DISABLED} = 1 if $nocolor;

=head1 Usage

hexinator.pl --file FILENAME

=head2 Options

=over 1

=item --file FILENAME

the file to "hexinate"

=item --match REGEX

A regex. Will only show lines matching this.

=item --width 20

The column width to print out.

=item --errors

If enabled, will only print lines with unicode errors.

=item --check_line LINE_NUMBER

Only check the given line number.

=back

=cut

my $printed_row = 0;
my $line_number = 0;

open my $fh, $file or die "Could not open $file: $!";
binmode $fh;
while ( my $line = <$fh> )
{
    $line_number++;
    
    next if ($check_line && $line_number != $check_line);
    
    my $is_error = 0;
    
    if ($errors_only)
    {
        if (!is_valid($line))
        {
            print color('magenta') . "$line_number INVALID UTF-8:\n" . color('reset');
        }
    }
    
    if (( !$match ) || ( $line =~ /$match/ ))
    {   
        my @bytes = split(//, $line);
        #my @hex = ( unpack("H*", $line) =~ m/../g );
        my $hexes = "";
        my $text = "";
        my $length = 0;
        
        my $total_bytes = 0;
        my $found_bytes = 0;
        
        my $hex_char = "";
        my $utf8_char = "";
        my $have_full_char = 0;
        
        my $bytesize = @bytes;
        #print "bytes: $bytesize\n";
        
        while (@bytes)
        {
            my $byte = shift @bytes;
            
            my $ord = ord($byte);
            my $binary = sprintf("%b ", $ord);
            
            # http://en.wikipedia.org/wiki/UTF-8
            #
            # One-byte codes are used only for the ASCII values 0 through 127.
            # In this case the UTF-8 code has the same value as the ASCII code.
            # The high-order bit of these codes is always 0.
            if ($ord <= 127)
            {
                $total_bytes = 1;
                $found_bytes = 1;
                
                $hex_char = get_hex($ord);
                if ($ord <= 31)
                {
                    # non-printable character
                    $utf8_char = "";
                }
                else
                {
                    $utf8_char = $byte;
                }
                
                $have_full_char = 1;
            }
            # The leading byte has two or more high-order 1s followed by a 0
            elsif ( $binary =~ /^(11+)0/ )
            {
                # The number of high-order 1s in the leading byte of a multi-byte sequence indicates the number of bytes in the sequence,
                # so that the length of the sequence can be determined without examining the continuation bytes.
                $total_bytes = length($1);
                $found_bytes = 1;
                
                $hex_char = color('magenta') . get_hex($ord) . color('reset');
                $utf8_char = $byte;
                $have_full_char = 0;
            }
            # while continuation bytes all have '10' in the high-order position
            elsif ( $binary =~ /^10/ )
            {
                $found_bytes++;
                $utf8_char .= $byte;
                
                if ($found_bytes == $total_bytes)
                {
                    $have_full_char = 1;
                    
                    if (is_valid($utf8_char))
                    {
                        $hex_char .= color('blue') . get_hex($ord) . color('reset');
                    }
                    else
                    {
                        $hex_char .= color('yellow') . get_hex($ord) . color('reset');
                    }
                }
                elsif ($found_bytes < $total_bytes)
                {
                    $hex_char .= color('blue') . get_hex($ord) . color('reset');
                }
                else
                {
                    $hex_char .= color('red') . get_hex($ord) . color('reset');
                }
            }
            else
            {
                $is_error = 1;
                
                $total_bytes = 1;
                $found_bytes = 1;
                
                $hex_char = color('red') . get_hex($ord) . color('reset');
                $utf8_char = '?';
                $have_full_char = 1;
            }
            
            if ( $have_full_char )
            {
                # don't print out anything until we have the requested number of bytes
                if ( $length + $total_bytes <= $column_width )
                {
                    $hexes .= $hex_char;
                    
                    $text .= $utf8_char;
                    $length += $total_bytes;
                }
                # the current byte will take the row over the requested number of bytes
                # print out what we have and start a new row
                else
                {
                    # don't print if the line is valid and we are only looking for invalid characters
                    unless (( $errors_only ) && ( !$is_error ))
                    {
                        print $hexes;
                        
                        my $leftover = $column_width - $length;

                        print "   "x$leftover;
                        print "    |$text| :$line_number\n";
                        print "\n" if ++$printed_row % 3 == 0;
                    }
                    
                    $is_error = 0;
                    $hexes = $hex_char;
                    $text = "$utf8_char";
                    $length = $total_bytes;
                }
            }
        }
        if ($length)
        {
            unless (( $errors_only ) && ( !$is_error ))
            {
                print $hexes;
                
                my $leftover = $column_width - $length;

                print "   "x$leftover;
                print "    |$text| :$line_number\n";
                print "\n" if ++$printed_row % 3 == 0;
            }
            
            $is_error = 0;
            $hexes = "";
            $text = "";
            $length = 0;
        }
    }
}
close $fh;

sub get_hex
{
    return sprintf("%2lX ", $_[0]);
}

sub is_valid
{
    my ($data) = @_;
    my $is_valid = $data =~ m/\A(?:
         [\x09\x0A\x0D\x20-\x7E]            # ASCII
       | [\xC2-\xDF][\x80-\xBF]             # non-overlong 2-byte
       |  \xE0[\xA0-\xBF][\x80-\xBF]        # excluding overlongs
       | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}  # straight 3-byte
       |  \xED[\x80-\x9F][\x80-\xBF]        # excluding surrogates
       |  \xF0[\x90-\xBF][\x80-\xBF]{2}     # planes 1-3
       | [\xF1-\xF3][\x80-\xBF]{3}          # planes 4-15
       |  \xF4[\x80-\x8F][\x80-\xBF]{2}     # plane 16
       )*\z/x;
    return $is_valid;
}
